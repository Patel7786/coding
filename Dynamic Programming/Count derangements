//Count number of derangements
// two cases are possible 
//case 1 when  an element replace by i th element then both are replace each other n-2 element left with n-2 space
//case 2 when an element replace with i th element and not palced i th at element place then n-1 element left with n-1 space.
// f(n)=(n-1)[f(n-1)+f(n-2)];

//recursion+memoization
public class Solution {
	public static long calculate(int n,long dp[])
	{
		if(n==1) return 0;
		if(n==2) return 1;
		long mod=1000000007;
		if(dp[n]!=-1) return dp[n];
		dp[n]=((n-1)*(calculate(n-1,dp) + calculate(n-2,dp)))%mod;
		return dp[n];
		
	}
	public static long countDerangements(int n) {
		// Write your code here.
		long ans=0;
		long prev1=1;
		long prev2=0;
		long dp[]=new long[n+1];
		for(int i=0;i<=n;i++)
		{
			dp[i]=-1;
		}
		return calculate(n,dp);
	}
}

// bottom approach
public static long calculate(int n)
	{
		
		long mod=1000000007;
		long dp[]=new long[n+1];
		
		for(int i=0;i<=n;i++)
		{
			dp[i]=-1;
		}
		dp[1]=0;
		dp[2]=1;
		for(int i=3;i<=n;i++)
		{
			dp[i]=((i-1)*(dp[i-1]+dp[i-2]))%mod;
		}
		return dp[n];
	}

    // space otimizion
    public static long calculate(int n)
	{
		
		long mod=1000000007;
		long dp[]=new long[n+1];
		
		
		long prev1=0;
		long prev2=1;
		for(int i=3;i<=n;i++)
		{
			long val=((i-1)*(prev1+prev2))%mod;
			prev1=prev2 ;
			prev2=val;
		}
		return prev2;
	}