//find longest common subsequences
//if s1[i]==s2[j] then 1+lcs(i+1,j+1);
//else move lcs(i+1,j),lcs(i,j+1) then return max

//Memoization approach
class Solution
{
    static int fastlcs(int x, int y, String s1, String s2,int index1,int index2,int dp[][])
    {
        if(index1>=x || index2>=y) return 0;
        if(dp[index1][index2]!=-1) return dp[index1][index2];
        int val=0;
       
            if(s1.charAt(index1)==s2.charAt(index2))
            {
                val=1+fastlcs(x,y,s1,s2,index1+1,index2+1,dp);
            }
            else
            {
                val=Math.max(fastlcs(x,y,s1,s2,index1+1,index2,dp),fastlcs(x,y,s1,s2,index1,index2+1,dp));
                
            }
      
        return dp[index1][index2]=val;
    }
    //Function to find the length of longest common subsequence in two strings.
    static int lcs(int x, int y, String s1, String s2)
    {
        // your code here
        int dp[][]=new int[x+1][y+1];
        for(int[] row:dp)
        {
            Arrays.fill(row,-1);
        }
        return fastlcs(x,y,s1,s2,0,0,dp);
    }
    
}

//optimize Approch
class Solution
{
    static int fastlcs(int x, int y, String s1, String s2)
    {
        
        int dp[][]=new int[x+1][y+1];
        dp[x][y]=0;
        for(int i=x-1;i>=0;i--)
        {
            int val=0;
            for(int j=y-1;j>=0;j--)
            {
                if(s1.charAt(i)==s2.charAt(j))
                {
                    dp[i][j]=1+dp[i+1][j+1];
                }
                else
                {
                    dp[i][j]=Math.max(dp[i+1][j],dp[i][j+1]);
                }
            }
        }
        return dp[0][0];
        
    }
    //Function to find the length of longest common subsequence in two strings.
    static int lcs(int x, int y, String s1, String s2)
    {
        // your code here
       
        return fastlcs(x,y,s1,s2);
    }
    
}