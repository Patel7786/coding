//Important question and also difficult
/*
first calculate previous total and multipulty with (k-1) colors which is give you different consicutive digit.
second calculate previous difference and multipulty with 1 beacuse (put last digit with respect to last element of previous difference digit);
*/
class Solution
{
    long count(int n,int k)
    {
        long mod=1000000007;
        if(n==1) return k;
        long dp[]=new long[n+1];
        dp[0]=0;
        dp[1]=k;
        long same=k;
        for(int i=2;i<=n;i++)
        {
            dp[i]=((dp[i-1]*(k-1))%mod+same)%mod;
            same=(dp[i-1]*(k-1))%mod;
            
        }
        return dp[n];
        /*
        if(n==1) return k;
        if(n==2) return (k*k)%mod;
        if(dp[n]!=-1) return dp[n];
        long a=count(n-2,k,dp)%mod;
        long b=count(n-1,k,dp)%mod;
        long c=(a+b)%mod;
        long d=((k-1)*c)%mod;
        dp[n]=d;
        return dp[n];*/
    }
    long countWays(int n,int k)
    {
        //code here
        
        long mod=1000000007;
        return count(n,k)%mod;
    }
}
