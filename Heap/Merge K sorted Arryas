/*
Very Very Important:
Approach:
1. create node that contais data,row,column.
2.insert into Priority Queue .//default priority queue is min-heap and use comparater for Node type value.
3.traverse the whole 2d arrays by using coumn+1<arr[0].size();
4.remove top element from the priority queue and added to the list.
5.return list.

Time Complexity - O(N*Mlog(N));
Space - O(N*M);
*/
class Node 
    {
        int data;
        int row;
        int column;
        Node(int data,int row,int column)
        {
            this.data=data;
            this.row=row;
            this.column=column;
        }
    }

class NodeComparator implements Comparator<Node>{
             
            // Overriding compare()method of Comparator 
                        // for descending order of cgpa
            public int compare(Node s1, Node s2) {
                return s1.data-s2.data;
                }
        }

class Solution
{
    
    
    //Function to merge k sorted arrays.
    public static ArrayList<Integer> mergeKArrays(int[][] arr,int k) 
    {
        // Write your code here.
        ArrayList<Integer> list=new ArrayList<Integer>();
        PriorityQueue<Node> pq=new PriorityQueue<>(k ,new NodeComparator());
        for(int i=0;i<k;i++)
        {
            Node node=new Node(arr[i][0],i,0);
            pq.add(node);
        }
        while(!pq.isEmpty())
        {
            Node temp=pq.remove();
            int j=temp.column;
            int i=temp.row;
            list.add(temp.data);
            if(j+1<k)
            {
                Node node=new Node(arr[i][j+1],i,j+1);
                pq.add(node);
            }
            
        }
        return list;
    }
}