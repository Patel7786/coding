/* 
Difficulty : Hard
Important
Questions:-
Given K sorted lists of integers, 
KSortedArray[] of size N each. The task is to find the smallest range that includes at least one element from each of the K lists. 
If more than one such range's are found, return the first such range found.
Input:
N = 5, K = 3
KSortedArray[][] = {{1 3 5 7 9},
                    {0 2 4 6 8},
                    {2 3 5 7 11}}
Output: 1 2
Explanation: K = 3
A:[1 3 5 7 9]
B:[0 2 4 6 8]
C:[2 3 5 7 11]


TimeCompexity : O(n*K log(K));
Auxiluary :Space: log(K);

Approach:
1.add every first element of each arr[i][0].
2.Also track max element from first arr[i][0].
3.Put into min heap in form Node which is containing Row,Column and data.
4.traverse the loop while(pq.size()>= size of row) because if min heap conatin element less then the row it means we have done one row traversal fully. 
so condition is given at least one element from each row so we stope traversing.
*/
class Node
    {
        int data;
        int row;
        int column;
        Node(int data,int row,int column)
        {
            this.data=data;
            this.row=row;
            this.column=column;
        }
    }
    class NodeComparator implements Comparator<Node>
    {
        public int compare(Node a,Node b)
        {
            return a.data-b.data;
        }
    }
class Solution
{
    
    
	static int[] findSmallestRange(int[][] KSortedArray,int n,int k)
	{
	    //add your code here
	    int arr[]=new int[2];
	    int max=Integer.MIN_VALUE;
	    int range=Integer.MAX_VALUE;
	    //int min=Integer.MAX_VALUE;
	    PriorityQueue<Node> pq=new PriorityQueue<>(k,new NodeComparator());
	    
	    //PriorityQueue<Node> maxpq=new PriorityQueue<>(Collections.reverseOrder());
	   for(int i=0;i<k;i++){
	       Node temp=new Node(KSortedArray[i][0],i,0);
	       pq.add(temp);
	       max=Math.max(max,KSortedArray[i][0]);
	       
	   } 
	   while(!pq.isEmpty() && pq.size()>=k)
	   {
	       Node min=pq.remove();
	       int i=min.row;
	       int j=min.column;
	       int val=max-min.data;
	       if(range>val)
	       {
	           arr[0]=min.data;
	           arr[1]=max;
	           range=val;
	       }
	       if(j+1<n)
	       {
	           max=Math.max(max,KSortedArray[i][j+1]);
	           Node temp=new Node(KSortedArray[i][j+1],i,j+1);
	           pq.add(temp);
	       }
	   }
	    return arr;
	}
}